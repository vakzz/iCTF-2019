#!/usr/bin/env python3

from pwn import *
from swpag_client import Team
import requests
import json
import re
import time
import os
from multiprocessing.dummy import Pool as ThreadPool
import importlib

# Logging configuration


class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'


original_info = log.info
log.info = lambda x: original_info(bcolors.OKBLUE + x + bcolors.ENDC)
log.header = lambda x: original_info(bcolors.HEADER + x + bcolors.ENDC)

original_success = log.success
log.success = lambda x: original_success(bcolors.OKGREEN + x + bcolors.ENDC)

original_failure = log.failure
log.failure = lambda x: original_failure(bcolors.FAIL + x + bcolors.ENDC)
log.fail_once = lambda x, errors_in_round: x in errors_in_round or log.failure(
    x)

# Team information
X_TEAM_TOKEN = "INSERT_TEAM_TOKEN"

# Submission server URL
SUBMISSION_URL = "http://api.ictf2020.net/"

# Message types
NO_SUCH_FLAG = "incorrect"
OWN_FLAG = "ownflag"
ALREADY_SUBMITTED = "alreadysubmitted"
ACCEPTED = "correct"
TOO_MANY_INCORRECT = "toomanyincorrect"
NOT_ACTIVE = "notactive"

# Delays and timeouts
REQUEST_TIMEOUT = 5  # HTTP Request timeouts (in seconds)
RECONNECT_DELAY = 3  # Delay before attempting a new connection (in seconds)

# Miscellaneous
EXPLOIT_FOLDER = "exploits"

# iCTF API
team = Team(SUBMISSION_URL, X_TEAM_TOKEN)


def is_valid_flag(flag):
    """
    Checks if a string matches the flag format
    """
    return True


def remove_invalid_flags(flags):
    """
    Takes a list of flags and removes flags with an invalid format
    Returns a list of valid flags (format-wise)
    """

    # Validate flag format
    filtered_flags = [flag for flag in flags if is_valid_flag(flag)]

    number_of_removed_flags = len(flags) - len(filtered_flags)

    if number_of_removed_flags:
        log.failure("Removed {} flags with incorrect format.".format(
            number_of_removed_flags))

    return filtered_flags


def print_statistics_from_flag_responses(flag_responses, flags_per_handler):

    stats = {}

    for handler in list(flags_per_handler.keys()):
        stats[handler] = {
            "number_of_invalid_flags": 0,
            "number_of_own_flags": 0,
            "number_of_already_submitted_flags": 0,
            "number_of_accepted_flags": 0,
            "total_points": 0
        }

    for response in flag_responses:

        current_handler = None

        # Find which handler submitted a given flag
        for handler in list(flags_per_handler.keys()):

            if response['flag'] in flags_per_handler[handler]:
                current_handler = handler

        if not current_handler:
            log.failure("Server responded with a flag that we have never submitted : {}".format(
                response['flag']))
            continue

        if response['message_type'] == NO_SUCH_FLAG:
            stats[current_handler]['number_of_invalid_flags'] += 1

        elif response['message_type'] == OWN_FLAG:
            stats[current_handler]['number_of_own_flags'] += 1

        elif response['message_type'] == ALREADY_SUBMITTED:
            stats[current_handler]['number_of_already_submitted_flags'] += 1

        elif response['message_type'] == ACCEPTED:
            stats[current_handler]['number_of_accepted_flags'] += 1
            stats[current_handler]['total_points'] += response['points']

        else:
            log.failure("Invalid message received : '{}'".format(
                response['message_type']))

    log.header("==== ROUND STATISTICS ===")
    for handler in list(stats.keys()):
        number_of_invalid_flags = stats[handler]['number_of_invalid_flags']
        number_of_own_flags = stats[handler]['number_of_own_flags']
        number_of_already_submitted_flags = stats[handler]['number_of_already_submitted_flags']
        number_of_accepted_flags = stats[handler]['number_of_accepted_flags']
        total_points = stats[handler]['total_points']

        log.header("{:30} | {:7} | {:3} | {:17} | {:8} | {:20} |".format("Handler name",
                                                                         "Invalid", "Own", "Already submitted", "Accepted", "Points"))

        log.header("{:30} | {:7} | {:3} | {:17} | {:8} | {:20} |".format(handler,
                                                                         number_of_invalid_flags, number_of_own_flags, number_of_already_submitted_flags,
                                                                         number_of_accepted_flags, total_points))


def parse_response(flag_response):
    """
    Parses each individual flag response returned from submit_flags()
    Returns a dictionary containing { flag, is_valid, message_type, points }
    """

    points = 0
    is_valid = False

    if NO_SUCH_FLAG in flag_response:
        message_type = NO_SUCH_FLAG

    if OWN_FLAG in flag_response:
        message_type = OWN_FLAG

    if ALREADY_SUBMITTED in flag_response:
        message_type = ALREADY_SUBMITTED

    if TOO_MANY_INCORRECT in flag_response:
        message_type = TOO_MANY_INCORRECT

    if NOT_ACTIVE in flag_response:
        message_type = NOT_ACTIVE

    if ACCEPTED in flag_response:
        message_type = ACCEPTED
        is_valid = True
        points = 1

    return {
        "flag": "N/A",
        "is_valid": is_valid,
        "message_type": message_type,
        "points": points
    }


def submit_flags(flags=[]):
    """
    Submit flags to the submission server and parses the responses.
    Returns the parsed flag responses.
    """

    log.success("Submitting {} flags.".format(len(flags)))

    # Loop until we receive a response from the submission server
    while True:
        try:
            responses = team.submit_flag(flags)
            flag_responses = [parse_response(
                flag_response) for flag_response in responses]
            return flag_responses

        except requests.ConnectionError as e:
            log.failure("Submission server is not up. Re-trying in {} seconds".format(
                RECONNECT_DELAY))
            time.sleep(RECONNECT_DELAY)

        except requests.ReadTimeout as e:
            log.failure("Submission server did not respond in {} seconds. Re-trying.".format(
                REQUEST_TIMEOUT))

        except Exception as e:
            log.failure(
                "An unknown error occured when submitting the flags : {}".format(e))

        time.sleep(1)


def register_handlers(path=EXPLOIT_FOLDER):
    """
    Register exploit handlers from the exploit folder
    Returns the list of registered handlers
    """

    exploit_folder = './{}/{}'.format(os.path.dirname(__file__), path)
    handlers = []

    for module in os.listdir(exploit_folder):

        if not module.endswith(".py") or module == "__init__.py":
            continue

        # Execute the script
        # We assume that each executed script registers himself to the handlers dictionary.
        try:
            exec(compile(open('./{}/{}'.format(path, module), "rb").read(),
                         './{}/{}'.format(path, module), 'exec'))
        except Exception as e:
            log.failure(
                "Could not register handler '{}' : {}".format(module, e))

    log.info("Registered {} handler(s).".format(len(handlers)))
    for handler in handlers:

        handler_name = handler.__name__
        log.info("- Registered '{}' handler".format(handler_name))

    return handlers


def get_opponent_ips():
    """
    Fetch the IPs of opponent teams.
    """
    global team

    while True:

        try:
            service_list = team.get_service_list()
            if service_list:
                service = service_list[0]
                targets = team.get_targets(service['service_id'])
                return [target['hostname'] for target in targets]
            else:
                return []
        except Exception as e:
            log.info("Could not fetch oppponent list. Retrying in {} seconds...".format(
                RECONNECT_DELAY))
            time.sleep(RECONNECT_DELAY)


if __name__ == '__main__':

    log.info("Starting exploit throwing framework...")

    # Main round loop
    while True:

        log.header("==== ROUND START ====")

        # Register handlers
        handlers = register_handlers()
        services_and_handlers = {}
        for handler in handlers:
            services_and_handlers[handler.SERVICE_NAME] = handler

        # Dictionary containing a list of flags for each handler
        flags_per_handler = {}

        # Keep track of errors for this round
        errors = set()

        # Load targets
        log.info("Loading targets...")
        targets = []
        for service in list(services_and_handlers.keys()):
            try:
                handler = services_and_handlers[service]
                targets += [(handler, t) for t in team.get_targets(service)]
            except Exception as e:
                log.failure('{} : {}'.format(handler.__name__, e))

        def exploit(xxx_todo_changeme):

            (handler, target) = xxx_todo_changeme
            handler_name = handler.__name__
            opponent_ip = target['hostname']
            flag_id = target['flag_id']

            results = []
            # Run each exploit
            try:
                flag = handler.get_flag(opponent_ip, flag_id)
                if flag != None:
                    results.append((handler_name, flag.strip()))

                handler.post_exploit(opponent_ip, flag_id)

            except Exception as e:
                error_message = "Service '{}' failed to get flag(s) : {}".format(
                    handler_name, e)

                log.fail_once(error_message, errors)
                errors.add(error_message)

            return results

        log.info("Submitting flags...")
        pool = ThreadPool(100)
        results = pool.map(exploit, targets)
        pool.close()
        pool.join()

        for l in results:
            for pair in l:
                flags = flags_per_handler.get(pair[0], [])
                flags.append(pair[1])
                flags_per_handler[pair[0]] = flags

        # Log number of flags per handler
        all_flags = []
        for handler in list(flags_per_handler.keys()):

            flags = flags_per_handler.get(handler, [])
            log.success("'{}' handler found {} flag(s).".format(
                handler, len(flags)))

            all_flags.extend(flags)

        # Filter out flags with incorrect format
        filtered_flags = remove_invalid_flags(all_flags)

        # Send flags to submission server
        flag_responses = submit_flags(filtered_flags)

        # Print statistics
        print_statistics_from_flag_responses(flag_responses, flags_per_handler)

        # Wait for next round
        try:
            tick_info = team.get_tick_info()
            seconds_left = tick['approximate_seconds_left']
        except:
            seconds_left = 30

        log.info("Waiting {} seconds before next round".format(seconds_left))
        time.sleep(seconds_left)
